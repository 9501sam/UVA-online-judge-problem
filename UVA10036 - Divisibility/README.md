# 題目意思<br>
給一長度為 n 的數列與一數 k，問在數列的相鄰兩數之間插入 '+' 或 '-'
<br>是否存在一運算法使得整個運算結果能夠被 k 整除。(1 <= n <= 10000, 2 <= k <= 100)
# 解題<br>
這題偏難，利用題目預設測資 
<br>2
<br>4 7
<br>17 5 -21 15
<br>4 5
<br>17 5 -21 15
<br>先看第一筆測資,m=4, k=7(除數), num=17,5,-21,15
<br>(17±5±-21±15) % 7 可以看成 ((17%7) + (5%7) + (-21%7) + (15%7)) % 7
```cpp
	//輸入m個數字，並將他們除以k的餘數算出
	for(int i=0;i<n;i++){
		cin >> num[i];
		num[i] = abs(num[i])%k;
	}
```
<br>利用array去紀錄，這個部分比較難理解：
```cpp
	int f[m+1][100]={0};
	f[0][0] = 1;
	for(int i=0;i<m;i++){
		for(int j=0;j<d;j++){
			if(f[i][j]){
				f[i+1][(j+k+num[i])%k] = 1;
				f[i+1][(j+k-num[i])%k] = 1;
					
			}
		}
	}
```
<br>一開始設定f[0][0]=1，從i=0開始，帶入公式
<br>**為何要j+k再±num[i](餘數)，因有可能j-num[i]<0，因此要再加上k讓其最後%k的數字為正**
<br><br>17%7=3, 5%7=5, -21%7=0, 15%7=1
<br>**i=0,j=0 (f[0][0]=1成立)**
> (0+7+3) % 7 = 3  **f[1(i+1)][3] = 1**
> (0+7-3) % 7 = 4  **f[1(i+1)][4] = 1**
<br>**i=0, j=1 (f[0][1]!=1不成立)**
<br>下面的就不會執行
> (1+7+3) % 7 = 3
> (1+7+3) % 7 = 3

<br>**i=1, j=0**
<br>**i=1, j=1**
<br>**i=1, j=2**
<br>**i=1, j=3 f[1][3]=1**
> (3+7+5) % 7 = 1  **f[2(i+1)][1] = 1**
> (3+7-5) % 7 = 5  **f[2(i+1)][5] = 1**
<br>**i=1, j=4 f[1][4]=1**
> (4+7+5) % 7 = 2  **f[2(i+1)][2] = 1**
> (4+7-5) % 7 = 6  **f[2(i+1)][6] = 1**
<br>依此類推，就是把第i-th / 7 的餘數± i+1-th / 7的餘數記錄下來
<br>若最後f[m][0] = 1則代表所有數字隨意帶入±的結果可以整除k(divisible) 
